function [J, grad] = costeRN(params_rn, num_entradas, num_ocultas,   num_etiquetas, X, y, lambda)   %============ PARTE 1 ===============================   Theta1 = reshape(params_rn(1:num_ocultas * (num_entradas + 1)),    num_ocultas, (num_entradas + 1));    Theta2 = reshape(params_rn((1 + (num_ocultas * (num_entradas + 1))):end),    num_etiquetas, (num_ocultas + 1));  m = size(X, 1);  I = eye(num_etiquetas);  Y = zeros(m, num_etiquetas);  for i=1:m    Y(i, :)= I(y(i), :);  end  a1 = [ones(m, 1) X];  z2 = a1 * Theta1';  a2 = [ones(size(z2, 1), 1) sigmoide(z2)];  z3 = a2*Theta2';  a3 = sigmoide(z3);    h_theta = a3;      prim = (1/m)*sum(sum((-Y).*log(h_theta) - (1-Y).*log(1 - h_theta), 2));    termino_reg = (lambda/(2*m))*(sum(sum(Theta1(:, 2:end).^2, 2)) +     sum(sum(Theta2(:,2:end).^2, 2)));  J = prim + termino_reg;  grad = 0;    %============ PARTE 2.1 ===============================     Sigma3 = a3 - Y;  Sigma2 = (Sigma3*Theta2 .* sigmoideDER([ones(size(z2, 1), 1) z2]))(:, 2:end);  Delta_1 = Sigma2'*a1;  Delta_2 = Sigma3'*a2;  %============ Con PARTE 2.3 a침adida ===================  % A la divisi칩n de D/m se ha a침adido la suma de regularizaci칩n  Theta1_grad = Delta_1./m + (lambda/m)*[zeros(size(Theta1,1), 1) Theta1(:, 2:end)];  Theta2_grad = Delta_2./m + (lambda/m)*[zeros(size(Theta2,1), 1) Theta2(:, 2:end)];  grad = [Theta1_grad(:) ; Theta2_grad(:)];  endfunction